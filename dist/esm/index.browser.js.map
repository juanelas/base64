{"version":3,"file":"index.browser.js","sources":["../../src/ts/index.ts","../../src/ts/browser-base64.ts"],"sourcesContent":["/**\n * Base64url for both node.js and brwser javascript. It can work with ArrayBuffer|TypedArray|Buffer\n *\n * @remarks Bowser code obtained from https://github.com/panva/jose/blob/main/src/runtime/browser/base64url.ts\n * @packageDocumentation\n */\n\nimport { base64Encode, base64Decode } from './browser-base64.js'\n\n/**\n * A TypedArray object describes an array-like view of an underlying binary data buffer.\n */\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array\n\n/**\n * Base64Url encoding of a buffer input or a string (UTF16 in browsers, UTF8 in node)\n * @param input\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a string with the base64-encoded representation of the input\n */\nexport function encode (input: ArrayBufferLike | TypedArray | Buffer | string, urlsafe: boolean = false, padding: boolean = true): string {\n  let base64 = ''\n  if (IS_BROWSER) {\n    const bytes = (typeof input === 'string')\n      ? (new TextEncoder()).encode(input)\n      : new Uint8Array(input)\n    base64 = base64Encode(bytes)\n  } else {\n    const bytes = (typeof input === 'string')\n      ? Buffer.from(input, 'utf8')\n      : Buffer.from(input)\n    base64 = bytes.toString('base64')\n  }\n  if (urlsafe) base64 = base64ToBase64url(base64)\n  if (!padding) base64 = removeBase64Padding(base64)\n  return base64\n}\n\n/**\n * Base64url decoding (binary output) of base64url-encoded string\n * @param base64 - a base64 string\n * @param stringOutput - if true a UTF16 (browser) or UTF8 (node) string is returned\n * @returns a buffer or unicode string\n */\nexport function decode (base64: string): Uint8Array\nexport function decode (base64: string, stringOutput: undefined): Uint8Array\nexport function decode (base64: string, stringOutput: false): Uint8Array\nexport function decode (base64: string, stringOutput: true): string\nexport function decode (base64: string, stringOutput: boolean): Uint8Array | string\nexport function decode (base64: string, stringOutput: undefined | boolean = false): Uint8Array | string {\n  if (IS_BROWSER) {\n    let urlsafe = false\n    if (/^[0-9a-zA-Z_-]+={0,2}$/.test(base64)) {\n      urlsafe = true\n    } else if (!/^[0-9a-zA-Z+/]*={0,2}$/.test(base64)) {\n      throw new Error('Not a valid base64 input')\n    }\n    if (urlsafe) base64 = base64urlToBase64(base64)\n    const bytes = base64Decode(base64)\n    return stringOutput\n      ? (new TextDecoder()).decode(bytes)\n      : bytes\n  } else {\n    const buffer = Buffer.from(base64, 'base64')\n    return stringOutput\n      ? buffer.toString('utf8')\n      : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length)\n  }\n}\n\nfunction base64ToBase64url (base64: string): string {\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_')\n}\n\nfunction base64urlToBase64 (base64url: string): string {\n  return base64url.replace(/-/g, '+').replace(/_/g, '/').replace(/=/g, '')\n}\n\nfunction removeBase64Padding (str: string): string {\n  return str.replace(/=/g, '')\n}\n","export const base64Encode = (bytes: Uint8Array): string => {\n  const CHUNK_SIZE = 0x8000\n  const arr = []\n  for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    // @ts-expect-error\n    arr.push(String.fromCharCode.apply(null, bytes.subarray(i, i + CHUNK_SIZE)))\n  }\n  return btoa(arr.join(''))\n}\n\nexport const base64Decode = (encoded: string): Uint8Array => {\n  return new Uint8Array(\n    atob(encoded)\n      .split('')\n      .map((c) => c.charCodeAt(0))\n  )\n}\n"],"names":["encode","input","urlsafe","padding","base64","bytes","arr","i","length","push","String","fromCharCode","apply","subarray","btoa","join","base64Encode","TextEncoder","Uint8Array","replace","base64ToBase64url","decode","stringOutput","test","Error","atob","split","map","c","charCodeAt","TextDecoder"],"mappings":"AAqBM,SAAUA,EAAQC,EAAuDC,GAAmB,EAAOC,GAAmB,GAC1H,IAAIC,EAAS,GAKXA,EC3BwB,CAACC,IAC3B,MACMC,EAAM,GACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,GAFf,MAIjBD,EAAIG,KAAKC,OAAOC,aAAaC,MAAM,KAAMP,EAAMQ,SAASN,EAAGA,EAJ1C,SAMnB,OAAOO,KAAKR,EAAIS,KAAK,IAAI,EDoBdC,CAHuB,iBAAVf,GAClB,IAAKgB,aAAejB,OAAOC,GAC3B,IAAIiB,WAAWjB,IAUrB,OAFIC,IAASE,EAqCf,SAA4BA,GAC1B,OAAOA,EAAOe,QAAQ,MAAO,KAAKA,QAAQ,MAAO,IACnD,CAvCwBC,CAAkBhB,IACnCD,IAASC,EAA6BA,EA6ChCe,QAAQ,KAAM,KA5ClBf,CACT,UAagBiB,EAAQjB,EAAgBkB,GAAoC,GAC1D,CACd,IAAIpB,GAAU,EACd,GAAI,yBAAyBqB,KAAKnB,GAChCF,GAAU,OACL,IAAK,yBAAyBqB,KAAKnB,GACxC,MAAM,IAAIoB,MAAM,4BAEdtB,IAASE,EAA2BA,EAkBzBe,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KAjBnE,MAAMd,EChDD,IAAIa,WACTO,KD+C2BrB,GC9CxBsB,MAAM,IACNC,KAAKC,GAAMA,EAAEC,WAAW,MD8C3B,OAAOP,GACH,IAAKQ,aAAeT,OAAOhB,GAC3BA,CAML,CACH"}